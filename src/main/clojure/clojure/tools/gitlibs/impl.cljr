;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(ns clojure.tools.gitlibs.impl
  "Implementation, use at your own risk"
  (:require
    [clojure.clr.io :as cio]                                                    ;;; [clojure.java.io :as jio]
    [clojure.string :as str]
    [clojure.tools.gitlibs.config :as config])
  (:import
    [System DateTime Environment]
    [System.Diagnostics ProcessStartInfo Process]                               ;;; [java.lang ProcessBuilder$Redirect]
    [System.IO Stream StringWriter FileInfo DirectoryInfo Path IOException Directory]     ;;; [java.io File FilenameFilter InputStream IOException StringWriter]
    [System.Threading Thread ThreadStart]))
(set! *warn-on-reflection* true)

;; io util

(defn printerrln [& msgs]
  (binding [*out* *err*]
    (apply println msgs)))

(defn- capture
  "Reads from input-stream until EOF and returns a String (or nil if 0 length)."
  [^Stream input-stream]                                                        ;;; ^InputStream
  (let [writer (StringWriter.)]
    (cio/copy input-stream writer)                                              ;;; jio/copy
    (let [s (str/trim (.ToString writer))]                                      ;;; .toString
      (when-not (zero? (.Length s))                                             ;;; .length
        s))))

(defmacro background
  [& body]
  `(let [result# (promise)]
     (doto (Thread. ^ThreadStart (gen-delegate ThreadStart [] (deliver result# (do ~@body))))              ;;; (fn [] (deliver result# (do ~@body)))
       (.set_IsBackground true)                                                                            ;;; .setDaemon
       (.Start))                                                                                           ;;; .start
     result#))

(defn run-git-with-config
  "Internal function that runs git with the given config and args."
  [config args]
  (let [{:gitlibs/keys [command debug terminal]} config
        command-args (cons command args)]
    (when debug
      (apply printerrln command-args))
    (let [proc-builder
	     (doto (ProcessStartInfo. ^String command ^String (clojure.string/join " " args))                  ;;; (ProcessBuilder. ^java.util.List command-args)
            (.set_RedirectStandardError true)
			(.set_RedirectStandardOutput true))
                                                                                                           ;;; (.redirectError proc-builder ProcessBuilder$Redirect/INHERIT)
          ;;;                                                                                              ;;;  _ (when-not terminal (.put (.environment proc-builder) "GIT_TERMINAL_PROMPT" "0"))
		  proc (Process/Start proc-builder)                                                                ;;; (.start proc-builder)
          out (background (capture (.StandardOutput proc)))                                                ;;;  .getInputStream
          err (background (capture (.StandardError proc)))                                                 ;; if debug is true, stderr will be redirected instead  .getErrorStream
          exit (do (.WaitForExit proc) (.ExitCode proc))]                                                                        ;;; .waitFor  -- but .WaitForExit returns void, so we have to add the ExitCode call
      {:args command-args, :exit exit, :out @out, :err @err})))

;; lock coordination for atomic git clone
;;
;; This section implements lock-file-based coordination to ensure that multiple
;; processes attempting to clone the same git repository to the same directory
;; do not race or interfere with each other.
;;
;; Algorithm:
;; 1. Fast path: If git dir exists and no lock file, return immediately (already cloned)
;; 2. Try to acquire lock by atomically creating a lock file
;; 3. If lock acquired:
;;    - Clone the repo directly into the target directory
;;    - Update timestamp in lock file every second during clone
;;    - Remove lock file on completion (success or failure)
;; 4. If lock not acquired (another process is cloning):
;;    - Wait for the clone to complete
;;    - Update timestamp in lock file every second while waiting
;;    - Check if timestamp expires (>10 seconds old) - if so, throw exception
;; 5. The timestamp mechanism ensures both cloner and waiter keep the lock "alive"
;;    and allows detection of dead/crashed processes
;;
;; This approach avoids PID reliance and uses only filesystem primitives and wall-clock time.

(defn- current-ts
  "Returns the current UTC timestamp as a string."
  []
  (.ToString (.ToUniversalTime (DateTime/Now))))

(defn- write-ts
  "Writes the current timestamp to the lock file."
  [^String lockfile]
  (System.IO.File/WriteAllText lockfile ^String (current-ts)))

(defn- read-ts
  "Reads the timestamp from the lock file and parses it as a DateTime.
   Returns nil if parsing fails or file doesn't exist."
  [^String lockfile]
  (try
    (when (System.IO.File/Exists lockfile)
      (DateTime/Parse (System.IO.File/ReadAllText lockfile)))
    (catch Exception _ nil)))

(defn- acquire-lock
  "Attempts to atomically create the lock file and writes the initial timestamp.
   Returns true if the lock was acquired, false otherwise."
  [^String lockfile]
  (try
    (let [fs (System.IO.File/Open lockfile System.IO.FileMode/CreateNew 
                                   System.IO.FileAccess/Write System.IO.FileShare/None)]
      (.Close fs)
      (write-ts lockfile)
      true)
    (catch System.IO.IOException _
      false)))

(defn- release-lock
  "Deletes the lock file, releasing the lock."
  [^String lockfile]
  (try
    (System.IO.File/Delete lockfile)
    (catch Exception _)))

(defn- timestamp-expired?
  "Returns true if the timestamp in the lock file is older than timeout-seconds.
   Returns true if the timestamp cannot be read."
  [^String lockfile timeout-seconds]
  (let [ts (read-ts lockfile)
        now (.ToUniversalTime (DateTime/Now))]
    (or (nil? ts)
        (> (.TotalSeconds (.Subtract ^DateTime now ^DateTime ts)) timeout-seconds))))

;; dirs

(defn lib-dir
  ^DirectoryInfo [lib]                                                                                     ;;; ^File
  (cio/dir-info (:gitlibs/dir @config/CONFIG) "libs" (namespace lib) (name lib)))                          ;;; jio/file

(def ^:private git-url-regex
  #"([a-z0-9+.-]+):\/\/(?:(?:(?:[^@]+?)@)?([^/]+?)(?::[0-9]*)?)?(/[^:]+)")

(def ^:private git-scp-regex
  #"(?:(?:[^@]+?)@)?(.+?):([^:]+)")

(defn- clean-url
  "Convert url into a safe relative path (this is not a reversible transformation)
  based on scheme, host, and path (drop user and port).

  Examples:
    ssh://git@gitlab.com:3333/org/repo.git     => ssh/gitlab.com/org/repo
    git@github.com:dotted.org/dotted.repo.git  => ssh/github.com/dotted.org/dotted.repo
    file://../foo                              => file/REL/_DOTDOT_/foo
    file:///Users/user/foo.git                 => file/Users/user/foo
    ../foo                                     => file/REL/_DOTDOT_/foo
    ~user/foo.git                              => file/REL/_TILDE_user/foo

  * https://git-scm.com/docs/git-clone#_git_urls
  * https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols
  "
  [url]
  (let [[scheme host path] (cond
                             (str/starts-with? url "file://") ["file" nil (-> url (subs 7) (str/replace #"^([^/])" "REL/$1"))]
                             (str/includes? url "://") (let [[_ s h p] (re-matches git-url-regex url)] [s h p])
                             (str/includes? url ":") (let [[_ h p] (re-matches git-scp-regex url)] ["ssh" h p])
                             :local-repo ["file" nil (str/replace url #"^([^/])" "REL/$1")])
        clean-path (-> path
                     (str/replace #"\.git/?$" "") ;; remove trailing .git or .git/
                     (str/replace #"~" "_TILDE_")) ;; replace ~ with _TILDE_
        dir-parts (->> (concat [scheme host] (str/split clean-path #"/")) ;; split on /
                    (remove str/blank?) ;; remove any missing path segments
                    (map #(-> % ({"." "_DOT_", ".." "_DOTDOT_"} %))))] ;; replace . or .. segments
    (str/join "/" dir-parts)))

(defn git-dir
  ^DirectoryInfo [url]                                                                            ;;; ^File
  (cio/dir-info (:gitlibs/dir @config/CONFIG) "_repos" (clean-url url)))                          ;;; jio/file

(defn- lock-dir
  "Returns the directory where lock files are stored."
  ^DirectoryInfo []
  (cio/dir-info (:gitlibs/dir @config/CONFIG) "_locks"))

(defn- lockfile-for-git-dir
  "Returns the lockfile path for a given git directory."
  ([^DirectoryInfo git-dir-file]
   (lockfile-for-git-dir @config/CONFIG git-dir-file))
  ([config ^DirectoryInfo git-dir-file]
   (let [lock-dir-path (lock-dir config)
         ;; Ensure lock directory exists
         _ (when-not (.Exists lock-dir-path)
             (Directory/CreateDirectory (.FullName lock-dir-path)))
         ;; Create a safe filename from the git dir path
         git-dir-name (.Replace (.FullName git-dir-file) (System.IO.Path/DirectorySeparatorChar) (char \_))
         git-dir-name (.Replace git-dir-name (System.IO.Path/AltDirectorySeparatorChar) (char \_))]
     (System.IO.Path/Join (.FullName lock-dir-path) (str git-dir-name ".lock")))))

(defn git-try-fetch
  "Try to fetch and return the error code (0=success)"
  [^FileInfo git-dir]                                                                             ;;; ^File
  (let [git-path (.FullName git-dir)                                                              ;;; .getCanonicalPath
        ;; NOTE: --prune-tags would be desirable here but was added in git 2.17.0
        {:keys [exit]} (run-git "--git-dir" git-path
                                "fetch" "--quiet" "--all" "--tags" "--prune")]
    exit))

(defn git-fetch
  [^DirectoryInfo git-dir]                                                                        ;;; ^File
  (let [git-path (.FullName git-dir)                                                              ;;; .getCanonicalPath
        ;; NOTE: --prune-tags would be desirable here but was added in git 2.17.0
        {:keys [exit err] :as ret} (run-git "--git-dir" git-path
                                     "fetch" "--quiet" "--all" "--tags" "--prune")]
    (when-not (zero? exit)
      (throw (ex-info (format "Unable to fetch %s%n%s" git-path err) ret)))))

;; TODO: restrict clone to an optional refspec?
(defn git-clone-bare
  [url ^DirectoryInfo git-dir]                                                                     ;;; ^File
  (printerrln "Cloning:" url)
  (let [git-path (.FullName git-dir)                                                               ;;; .getCanonicalPath
        {:keys [exit err] :as ret} (run-git "clone" "--quiet" "--mirror" url git-path)]
    (when-not (zero? exit)
      (throw (ex-info (format "Unable to clone %s%n%s" git-path err) ret)))
    git-dir))

(defn- clone-with-timestamp-updates
  "Clones the repo to the target directory while updating the lock file timestamp every second.
   Throws if the timestamp expires or clone fails. On failure, deletes the git dir."
  ([url ^DirectoryInfo git-dir ^String lockfile timeout-seconds]
   (clone-with-timestamp-updates @config/CONFIG url git-dir lockfile timeout-seconds))
  ([config url ^DirectoryInfo git-dir ^String lockfile timeout-seconds]
   (printerrln "Cloning:" url)
   (let [git-path (.FullName git-dir)
         ;; Start the git clone in a future so we can update timestamps
         clone-future (future
                        (try
                          (run-git-with-config config ["clone" "--quiet" "--mirror" url git-path])
                          (catch Exception e
                            {:exception e})))
         clone-result (atom nil)]
     (try
       (loop []
         (let [result (deref clone-future 1000 ::running)]
           (if (= result ::running)
             ;; Still running - update timestamp and check expiry
             (do
               (write-ts lockfile)
               (if (timestamp-expired? lockfile timeout-seconds)
                 (do
                   ;; Timeout - try to cancel future (best effort)
                   (future-cancel clone-future)
                   ;; Clean up partial clone before throwing
                   (when (.Exists git-dir)
                     (try
                       (Directory/Delete git-path true)
                       (catch Exception _)))
                   (throw (ex-info "Clone timed out (lock expired)" {:url url :git-path git-path})))
                 (recur)))
             ;; Clone finished
             (do
               (reset! clone-result result)
               ;; Check if it was an exception
               (when (map? result)
                 (when-let [e (:exception result)]
                   ;; Clean up partial clone before throwing
                   (when (.Exists git-dir)
                     (try
                       (Directory/Delete git-path true)
                       (catch Exception _)))
                   (throw e)))
               ;; Check exit code
               (let [exit (:exit result)]
                 (when-not (zero? exit)
                   (let [err (:err result)]
                     ;; Clean up partial clone before throwing
                     (when (.Exists git-dir)
                       (try
                         (Directory/Delete git-path true)
                         (catch Exception _)))
                     (throw (ex-info (format "Unable to clone %s%n%s" git-path err) {:exit exit :err err})))))))))
       (catch Exception e
         ;; Cancel future on exception (best effort)
         (future-cancel clone-future)
         ;; Clean up partial clone before re-throwing
         (when (.Exists git-dir)
           (try
             (Directory/Delete git-path true)
             (catch Exception _)))
         (throw e))))))

(defn- wait-for-clone-completion
  "Waits for the clone to complete by checking if the git dir config file exists.
   Updates the lock file timestamp every second while waiting.
   Throws if the lock file timestamp expires or if git dir doesn't exist after lock is released."
  [^String config-file-path ^String lockfile timeout-seconds]
  (loop []
    (cond
      ;; Clone completed successfully
      (System.IO.File/Exists config-file-path)
      nil
      
      ;; Lock file removed - cloner finished (successfully or not)
      (not (System.IO.File/Exists lockfile))
      nil
      
      ;; Lock file expired - cloner is dead
      (timestamp-expired? lockfile timeout-seconds)
      (throw (ex-info "Cloner process dead (lock expired)" {}))
      
      ;; Still waiting - update timestamp and continue
      ;; NOTE: We must check lockfile exists again before writing, because
      ;; write-ts will create the file if it doesn't exist, which would cause
      ;; us to recreate a lock that was just released
      :else
      (if (System.IO.File/Exists lockfile)
        (do
          (write-ts lockfile)
          (Thread/Sleep 1000)
          (recur))
        ;; Lockfile was deleted while we were checking - exit loop
        nil)))
  ;; After lock is released, verify the git dir was successfully created
  (when-not (System.IO.File/Exists config-file-path)
    (throw (ex-info "Clone failed - git directory not created" {}))))

(defn ensure-git-dir
  "Ensure the bare git dir for the specified url, return the path to the git dir.
   
   Uses lock-file-based coordination to prevent race conditions when multiple processes
   attempt to clone the same repository simultaneously. The algorithm:
   
   1. Fast path: If git dir exists and no lock file, return immediately
   2. Try to acquire lock by atomically creating lock file
   3. If lock acquired: clone repo, update timestamp, release lock
   4. If lock held by another process: wait for clone, update timestamp, check for expiry
   
   The lock file contains a timestamp that both the cloner and waiting processes update
   every second. If the timestamp becomes >10 seconds old, it indicates a dead process
   and an exception is thrown."
  ([url]
   (ensure-git-dir @config/CONFIG url))
  ([config url]
   (let [git-dir-file (git-dir config url)
         config-file (cio/file-info git-dir-file "config")
         config-file-path (.FullName config-file)
         lockfile (lockfile-for-git-dir config git-dir-file)
         timeout-seconds 10]
     ;; Fast path: if config exists and no lock file, we're done
     (if (and (.Exists config-file) (not (System.IO.File/Exists lockfile)))
       (.FullName git-dir-file)
       ;; Otherwise, coordinate the clone
       (if (acquire-lock lockfile)
         ;; We acquired the lock - we are responsible for cloning
         (let [success? (atom false)]
             (try
               (when-not (.Exists config-file)
                 (clone-with-timestamp-updates config url git-dir-file lockfile timeout-seconds))
               (reset! success? true)
               (.FullName git-dir-file)
               (catch Exception e
                 ;; On exception, delete git dir first
                 (when (.Exists git-dir-file)
                   (try
                     (Directory/Delete (.FullName git-dir-file) true)
                     (catch Exception _)))
                 (throw e))
               (finally
                 ;; Always release lock, but only if we didn't succeed should git dir be deleted
                 ;; (git dir deletion happens in catch block before we get here)
                 (release-lock lockfile))))
         ;; Another process holds the lock - wait for clone to complete
         (do
           (when (:gitlibs/debug config)
             (printerrln "Waiting for another process to complete clone of:" url))
           (try
             (wait-for-clone-completion config-file-path lockfile timeout-seconds)
             (.FullName git-dir-file)
             (catch Exception e
               (throw e)))))))))

(defn git-checkout
  [git-dir-path ^DirectoryInfo lib-dir ^String rev]                                               ;;; ^File
  (let [rev-file (cio/file-info lib-dir rev)]                                                     ;;; jio/file
    (when-not (.Exists rev-file)                                                                  ;;; .exists 
      (let [{:keys [exit err] :as ret}
            (run-git "--git-dir" git-dir-path
              "worktree" "add" "--force" "--detach"
              (.FullName rev-file) rev)]                                                          ;;; .getCanonicalPath
        (when-not (zero? exit)
          (throw (ex-info (format "Unable to checkout %s%n%s" rev err) ret)))))))

(defn git-rev-parse
  [git-dir rev]
  (let [{:keys [exit out]} (run-git "--git-dir" git-dir "rev-parse" (str rev "^{commit}"))]
    (when (zero? exit)
      (str/trimr out))))

(defn git-type
  [git-dir rev]
  (let [{:keys [exit out]} (run-git "--git-dir" git-dir "cat-file" "-t" rev)]
    (when (zero? exit)
      (keyword (str/trimr out)))))

;; git merge-base --is-ancestor <maybe-ancestor-commit> <descendant-commit>
(defn- ancestor?
  [git-dir x y]
  (let [{:keys [exit err] :as ret} (run-git "--git-dir" git-dir "merge-base" "--is-ancestor" x y)]
    (condp = exit
      0 true
      1 false
      (throw (ex-info (format "Unable to compare commits %s%n%s" git-dir err) ret)))))

(defn commit-comparator
  [git-dir x y]
  (cond
    (= x y) 0
    (ancestor? git-dir x y) 1
    (ancestor? git-dir y x) -1
    :else (throw (ex-info "" {}))))

(defn match-exact
  "In dir, match file in dir with exact, nil if doesn't exist"
  [^DirectoryInfo dir exact]                                                    ;;; ^File
  (when (.Exists (cio/file-info dir exact))                                     ;;; .exists  jio/file
    exact))

(defn match-prefix
  "In dir, match file in dir with prefix, nil if not found, exception if more than one."
  [^DirectoryInfo dir prefix]                                                                               ;;; ^File
  (when (.Exists dir)                                                                                       ;;; .exists
    (if (.Exists (cio/file-info dir prefix))                                                                ;;; .exists  jio/file
      prefix
      (let [matches (.GetFiles dir (str name "*"))]                                                   ;;; (.listFiles dir
                                                                                                            ;;;       (reify FilenameFilter
                                                                                                            ;;;         (accept [_this _dir name]
                                                                                                            ;;;             (str/starts-with? name prefix))))]
        (case (alength matches)                                                                               ;;; alength
          0 nil
          1 (.Name ^FileInfo (first matches))                                                               ;;; (.getName ^File (aget matches 0))
          (throw (IOException. (str "Prefix not unique: " prefix))))))))

(defn tags
  "Fetch, then return all tags in the git dir."
  [git-dir]
  (git-try-fetch (cio/as-dir git-dir))                                                                       ;;; jio/file
  (let [{:keys [exit out err] :as ret} (run-git "--git-dir" git-dir "tag" "--sort=v:refname")]
    (when-not (zero? exit)
      (throw (ex-info (format "Unable to get tags %s%n%s" git-dir err) ret)))
    (remove str/blank? (str/split-lines out))))


