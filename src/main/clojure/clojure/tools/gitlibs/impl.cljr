;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(ns clojure.tools.gitlibs.impl
  "Implementation, use at your own risk"
  (:require
    [clojure.clr.io :as cio]                                                    ;;; [clojure.java.io :as jio]
    [clojure.string :as str]
    [clojure.tools.gitlibs.config :as config])
  (:import
    [System DateTime]
    [System.Diagnostics ProcessStartInfo Process]                               ;;; [java.lang ProcessBuilder$Redirect]
    [System.IO Stream StringWriter FileInfo DirectoryInfo Path IOException]     ;;; [java.io File FilenameFilter InputStream IOException StringWriter]
    [System.Threading Thread ThreadStart]))
(set! *warn-on-reflection* true)

;; io util

(defn printerrln [& msgs]
  (binding [*out* *err*]
    (apply println msgs)))

(defn- capture
  "Reads from input-stream until EOF and returns a String (or nil if 0 length)."
  [^Stream input-stream]                                                        ;;; ^InputStream
  (let [writer (StringWriter.)]
    (cio/copy input-stream writer)                                              ;;; jio/copy
    (let [s (str/trim (.ToString writer))]                                      ;;; .toString
      (when-not (zero? (.Length s))                                             ;;; .length
        s))))

(defmacro background
  [& body]
  `(let [result# (promise)]
     (doto (Thread. ^ThreadStart (gen-delegate ThreadStart [] (deliver result# (do ~@body))))              ;;; (fn [] (deliver result# (do ~@body)))
       (.set_IsBackground true)                                                                            ;;; .setDaemon
       (.Start))                                                                                           ;;; .start
     result#))

(defn- run-git
  [& args]
  (let [{:gitlibs/keys [command debug terminal]} @config/CONFIG
        command-args (cons command args)]
    (when debug
      (apply printerrln command-args))
    (let [proc-builder
	     (doto (ProcessStartInfo. ^String command ^String (clojure.string/join " " args))                  ;;; (ProcessBuilder. ^java.util.List command-args)
            (.set_RedirectStandardError true)
			(.set_RedirectStandardOutput true))
                                                                                                           ;;; (.redirectError proc-builder ProcessBuilder$Redirect/INHERIT)
          ;;;                                                                                              ;;;  _ (when-not terminal (.put (.environment proc-builder) "GIT_TERMINAL_PROMPT" "0"))
		  proc (Process/Start proc-builder)                                                                ;;; (.start proc-builder)
          out (background (capture (.StandardOutput proc)))                                                ;;;  .getInputStream
          err (background (capture (.StandardError proc)))                                                 ;; if debug is true, stderr will be redirected instead  .getErrorStream
          exit (do (.WaitForExit proc) (.ExitCode proc))]                                                                        ;;; .waitFor  -- but .WaitForExit returns void, so we have to add the ExitCode call
      {:args command-args, :exit exit, :out @out, :err @err})))

;; lock coordination for atomic git clone
;;
;; This section implements lock-file-based coordination to ensure that multiple
;; processes attempting to clone the same git repository to the same directory
;; do not race or interfere with each other.
;;
;; Algorithm:
;; 1. Fast path: If git dir exists and no lock file, return immediately (already cloned)
;; 2. Try to acquire lock by atomically creating a lock file
;; 3. If lock acquired:
;;    - Clone the repo directly into the target directory
;;    - Update timestamp in lock file every second during clone
;;    - Remove lock file on completion (success or failure)
;; 4. If lock not acquired (another process is cloning):
;;    - Wait for the clone to complete
;;    - Update timestamp in lock file every second while waiting
;;    - Check if timestamp expires (>10 seconds old) - if so, throw exception
;; 5. The timestamp mechanism ensures both cloner and waiter keep the lock "alive"
;;    and allows detection of dead/crashed processes
;;
;; This approach avoids PID reliance and uses only filesystem primitives and wall-clock time.

(defn- current-ts
  "Returns the current UTC timestamp as a string."
  []
  (.ToString (.ToUniversalTime (DateTime/Now))))

(defn- write-ts
  "Writes the current timestamp to the lock file."
  [^String lockfile]
  (System.IO.File/WriteAllText lockfile ^String (current-ts)))

(defn- read-ts
  "Reads the timestamp from the lock file and parses it as a DateTime.
   Returns nil if parsing fails or file doesn't exist."
  [^String lockfile]
  (try
    (when (System.IO.File/Exists lockfile)
      (DateTime/Parse (System.IO.File/ReadAllText lockfile)))
    (catch Exception _ nil)))

(defn- acquire-lock
  "Attempts to atomically create the lock file and writes the initial timestamp.
   Returns true if the lock was acquired, false otherwise."
  [^String lockfile]
  (try
    (let [fs (System.IO.File/Open lockfile System.IO.FileMode/CreateNew 
                                   System.IO.FileAccess/Write System.IO.FileShare/None)]
      (.Close fs)
      (write-ts lockfile)
      true)
    (catch System.IO.IOException _
      false)))

(defn- release-lock
  "Deletes the lock file, releasing the lock."
  [^String lockfile]
  (try
    (System.IO.File/Delete lockfile)
    (catch Exception _)))

(defn- timestamp-expired?
  "Returns true if the timestamp in the lock file is older than timeout-seconds.
   Returns true if the timestamp cannot be read."
  [^String lockfile timeout-seconds]
  (let [ts (read-ts lockfile)
        now (.ToUniversalTime (DateTime/Now))]
    (or (nil? ts)
        (> (.TotalSeconds (.Subtract ^DateTime now ^DateTime ts)) timeout-seconds))))

;; dirs

(defn lib-dir
  ^DirectoryInfo [lib]                                                                                     ;;; ^File
  (cio/dir-info (:gitlibs/dir @config/CONFIG) "libs" (namespace lib) (name lib)))                          ;;; jio/file

(def ^:private git-url-regex
  #"([a-z0-9+.-]+):\/\/(?:(?:(?:[^@]+?)@)?([^/]+?)(?::[0-9]*)?)?(/[^:]+)")

(def ^:private git-scp-regex
  #"(?:(?:[^@]+?)@)?(.+?):([^:]+)")

(defn- clean-url
  "Convert url into a safe relative path (this is not a reversible transformation)
  based on scheme, host, and path (drop user and port).

  Examples:
    ssh://git@gitlab.com:3333/org/repo.git     => ssh/gitlab.com/org/repo
    git@github.com:dotted.org/dotted.repo.git  => ssh/github.com/dotted.org/dotted.repo
    file://../foo                              => file/REL/_DOTDOT_/foo
    file:///Users/user/foo.git                 => file/Users/user/foo
    ../foo                                     => file/REL/_DOTDOT_/foo
    ~user/foo.git                              => file/REL/_TILDE_user/foo

  * https://git-scm.com/docs/git-clone#_git_urls
  * https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols
  "
  [url]
  (let [[scheme host path] (cond
                             (str/starts-with? url "file://") ["file" nil (-> url (subs 7) (str/replace #"^([^/])" "REL/$1"))]
                             (str/includes? url "://") (let [[_ s h p] (re-matches git-url-regex url)] [s h p])
                             (str/includes? url ":") (let [[_ h p] (re-matches git-scp-regex url)] ["ssh" h p])
                             :local-repo ["file" nil (str/replace url #"^([^/])" "REL/$1")])
        clean-path (-> path
                     (str/replace #"\.git/?$" "") ;; remove trailing .git or .git/
                     (str/replace #"~" "_TILDE_")) ;; replace ~ with _TILDE_
        dir-parts (->> (concat [scheme host] (str/split clean-path #"/")) ;; split on /
                    (remove str/blank?) ;; remove any missing path segments
                    (map #(-> % ({"." "_DOT_", ".." "_DOTDOT_"} %))))] ;; replace . or .. segments
    (str/join "/" dir-parts)))

(defn git-dir
  ^DirectoryInfo [url]                                                                            ;;; ^File
  (cio/dir-info (:gitlibs/dir @config/CONFIG) "_repos" (clean-url url)))                          ;;; jio/file

(defn git-try-fetch
  "Try to fetch and return the error code (0=success)"
  [^FileInfo git-dir]                                                                             ;;; ^File
  (let [git-path (.FullName git-dir)                                                              ;;; .getCanonicalPath
        ;; NOTE: --prune-tags would be desirable here but was added in git 2.17.0
        {:keys [exit]} (run-git "--git-dir" git-path
                                "fetch" "--quiet" "--all" "--tags" "--prune")]
    exit))

(defn git-fetch
  [^DirectoryInfo git-dir]                                                                        ;;; ^File
  (let [git-path (.FullName git-dir)                                                              ;;; .getCanonicalPath
        ;; NOTE: --prune-tags would be desirable here but was added in git 2.17.0
        {:keys [exit err] :as ret} (run-git "--git-dir" git-path
                                     "fetch" "--quiet" "--all" "--tags" "--prune")]
    (when-not (zero? exit)
      (throw (ex-info (format "Unable to fetch %s%n%s" git-path err) ret)))))

;; TODO: restrict clone to an optional refspec?
(defn git-clone-bare
  [url ^DirectoryInfo git-dir]                                                                     ;;; ^File
  (printerrln "Cloning:" url)
  (let [git-path (.FullName git-dir)                                                               ;;; .getCanonicalPath
        {:keys [exit err] :as ret} (run-git "clone" "--quiet" "--mirror" url git-path)]
    (when-not (zero? exit)
      (throw (ex-info (format "Unable to clone %s%n%s" git-path err) ret)))
    git-dir))

(defn- clone-with-timestamp-updates
  "Clones the repo to the target directory while updating the lock file timestamp every second.
   Throws if the timestamp expires or clone fails."
  [url ^DirectoryInfo git-dir ^String lockfile timeout-seconds]
  (printerrln "Cloning:" url)
  (let [git-path (.FullName git-dir)
        proc-builder (doto (ProcessStartInfo. ^String (:gitlibs/command @config/CONFIG) 
                                              ^String (str "clone --quiet --mirror " url " " git-path))
                       (.set_RedirectStandardError true)
                       (.set_RedirectStandardOutput true))
        ^Process proc (Process/Start proc-builder)
        clone-result (atom nil)]
    (try
      (loop []
        (if (.HasExited proc)
          (let [exit (.ExitCode proc)]
            (reset! clone-result exit)
            (when-not (zero? exit)
              (let [err (capture (.StandardError proc))]
                (throw (ex-info (format "Unable to clone %s%n%s" git-path err) {:exit exit :err err})))))
          (do
            (write-ts lockfile)
            (if (timestamp-expired? lockfile timeout-seconds)
              (do
                (.Kill proc)
                (throw (ex-info "Clone timed out (lock expired)" {:url url :git-path git-path})))
              (do
                (Thread/Sleep 1000)
                (recur))))))
      (catch Exception e
        (try
          (.Kill proc)
          (catch Exception _))
        (throw e)))))

(defn- wait-for-clone-completion
  "Waits for the clone to complete by checking if the git dir config file exists.
   Updates the lock file timestamp every second while waiting.
   Throws if the lock file timestamp expires."
  [config-file-path ^String lockfile timeout-seconds]
  (loop []
    (when-not (System.IO.File/Exists config-file-path)
      (write-ts lockfile)
      (if (timestamp-expired? lockfile timeout-seconds)
        (throw (ex-info "Cloner process dead (lock expired)" {}))
        (do
          (Thread/Sleep 1000)
          (recur))))))

(defn ensure-git-dir
  "Ensure the bare git dir for the specified url, return the path to the git dir.
   
   Uses lock-file-based coordination to prevent race conditions when multiple processes
   attempt to clone the same repository simultaneously. The algorithm:
   
   1. Fast path: If git dir exists and no lock file, return immediately
   2. Try to acquire lock by atomically creating lock file
   3. If lock acquired: clone repo, update timestamp, release lock
   4. If lock held by another process: wait for clone, update timestamp, check for expiry
   
   The lock file contains a timestamp that both the cloner and waiting processes update
   every second. If the timestamp becomes >10 seconds old, it indicates a dead process
   and an exception is thrown."
  [url]
  (let [git-dir-file (git-dir url)
        config-file (cio/file-info git-dir-file "config")
        config-file-path (.FullName config-file)
        lockfile (str (.FullName git-dir-file) ".lock")
        timeout-seconds 10]
    ;; Fast path: if config exists and no lock file, we're done
    (if (and (.Exists config-file) (not (System.IO.File/Exists lockfile)))
      (.FullName git-dir-file)
      ;; Otherwise, coordinate the clone
      (if (acquire-lock lockfile)
        ;; We acquired the lock - we are responsible for cloning
        (try
          (when-not (.Exists config-file)
            (clone-with-timestamp-updates url git-dir-file lockfile timeout-seconds))
          (.FullName git-dir-file)
          (finally
            (release-lock lockfile)))
        ;; Another process holds the lock - wait for clone to complete
        (do
          (when (:gitlibs/debug @config/CONFIG)
            (printerrln "Waiting for another process to complete clone of:" url))
          (try
            (wait-for-clone-completion config-file-path lockfile timeout-seconds)
            (.FullName git-dir-file)
            (catch Exception e
              (throw e))))))))

(defn git-checkout
  [git-dir-path ^DirectoryInfo lib-dir ^String rev]                                               ;;; ^File
  (let [rev-file (cio/file-info lib-dir rev)]                                                     ;;; jio/file
    (when-not (.Exists rev-file)                                                                  ;;; .exists 
      (let [{:keys [exit err] :as ret}
            (run-git "--git-dir" git-dir-path
              "worktree" "add" "--force" "--detach"
              (.FullName rev-file) rev)]                                                          ;;; .getCanonicalPath
        (when-not (zero? exit)
          (throw (ex-info (format "Unable to checkout %s%n%s" rev err) ret)))))))

(defn git-rev-parse
  [git-dir rev]
  (let [{:keys [exit out]} (run-git "--git-dir" git-dir "rev-parse" (str rev "^{commit}"))]
    (when (zero? exit)
      (str/trimr out))))

(defn git-type
  [git-dir rev]
  (let [{:keys [exit out]} (run-git "--git-dir" git-dir "cat-file" "-t" rev)]
    (when (zero? exit)
      (keyword (str/trimr out)))))

;; git merge-base --is-ancestor <maybe-ancestor-commit> <descendant-commit>
(defn- ancestor?
  [git-dir x y]
  (let [{:keys [exit err] :as ret} (run-git "--git-dir" git-dir "merge-base" "--is-ancestor" x y)]
    (condp = exit
      0 true
      1 false
      (throw (ex-info (format "Unable to compare commits %s%n%s" git-dir err) ret)))))

(defn commit-comparator
  [git-dir x y]
  (cond
    (= x y) 0
    (ancestor? git-dir x y) 1
    (ancestor? git-dir y x) -1
    :else (throw (ex-info "" {}))))

(defn match-exact
  "In dir, match file in dir with exact, nil if doesn't exist"
  [^DirectoryInfo dir exact]                                                    ;;; ^File
  (when (.Exists (cio/file-info dir exact))                                     ;;; .exists  jio/file
    exact))

(defn match-prefix
  "In dir, match file in dir with prefix, nil if not found, exception if more than one."
  [^DirectoryInfo dir prefix]                                                                               ;;; ^File
  (when (.Exists dir)                                                                                       ;;; .exists
    (if (.Exists (cio/file-info dir prefix))                                                                ;;; .exists  jio/file
      prefix
      (let [matches (.GetFiles dir (str name "*"))]                                                   ;;; (.listFiles dir
                                                                                                            ;;;       (reify FilenameFilter
                                                                                                            ;;;         (accept [_this _dir name]
                                                                                                            ;;;             (str/starts-with? name prefix))))]
        (case (alength matches)                                                                               ;;; alength
          0 nil
          1 (.Name ^FileInfo (first matches))                                                               ;;; (.getName ^File (aget matches 0))
          (throw (IOException. (str "Prefix not unique: " prefix))))))))

(defn tags
  "Fetch, then return all tags in the git dir."
  [git-dir]
  (git-try-fetch (cio/as-dir git-dir))                                                                       ;;; jio/file
  (let [{:keys [exit out err] :as ret} (run-git "--git-dir" git-dir "tag" "--sort=v:refname")]
    (when-not (zero? exit)
      (throw (ex-info (format "Unable to get tags %s%n%s" git-dir err) ret)))
    (remove str/blank? (str/split-lines out))))